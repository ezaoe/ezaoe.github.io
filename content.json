{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/12/09/hello-world/"},{"title":"redis入门","text":"前言Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings） 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 [TOC] 环境搭建安装rediscentos安装redis过程如下 12345678910111213141516# 下载最新稳定包，截止2017年5月最新稳定版本是Redis 3.2.8wget http://download.redis.io/releases/redis-3.2.8.tar.gz# 解压gz包tar xzf redis-3.2.8.tar.gz# 进入解压后的文件夹cd redis-3.2.8# 编译前安装gcc tcl 此步可忽略，编译redis错误时返回再执行也可以yum install gccyum install tcl# 编译redismake# 安装redis，会将make编译生成的可执行文件拷贝到/usr/local/bin目录下make install# 测试redis，成功后显示【\\o/ All tests passed without errors!】make test 配置redis刚刚的redis目录下会生成一个redis模板配置文件redis.conf，我们的配置可以基于此文件进行。配置过程如下： 1234567891011# 新建目录，用于存放redis的配置文件mkdir /etc/redis# 新建目录，用于存放redis持久化文件mkdir -p /var/redis/6379# 新建pid文件,文件内容为6379,保存退出vim /var/run/redis_6379.pid# 拷贝源码根目录配置模板redis.conf到刚刚创建的/etc/redis文件夹下cp redis.conf /etc/redis/6379.conf# 修改6379.conf文件vim /etc/redis/6379.conf 主要配置项如下 参数 值 说明 daemonize yes 设置redis以守护进程模式运行 pidfile /var/run/redis_端口号.pid 设置redis的PID文件位置 port 端口号 设置redis监听的端口号 dir /var/redis/端口号 设置持久化文档的存放位置 bind 默认127.0.0.1 禁用后，外网可访问，注意下面的属性 protected-mode 默认yes 禁止公网访问redis cache requirepass 密码值 设置密码 注意： 当Redis 以守护进程的方式运行的时候，Redis 默认会把 pid 文件放在/var/run/redis.pid，可配置到其他地址，当运行多个 redis 服务时，需要指定不同的 pid 文件和端口【PID (Process ID)：线程ID】 Redis3.2 之后加入的新特性Protected-mode 是为了禁止公网访问redis cache，加强redis安全的。它启用的条件，有两个： 没有bind IP 没有设置访问密码 设置开机自动启动redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# ./utils/install_server.sh Welcome to the redis service installerThis script will help you easily set up a running redis serverPlease select the redis port for this instance: [6379] 6379Please select the redis config file name [/etc/redis/6379.conf] Selected default - /etc/redis/6379.confPlease select the redis log file name [/var/log/redis_6379.log] Selected default - /var/log/redis_6379.logPlease select the data directory for this instance [/var/lib/redis/6379] /var/rPlease select the redis executable path [/usr/local/bin/redis-server] Selected config:Port : 6379Config file : /etc/redis/6379.confLog file : /var/log/redis_6379.logData dir : /var/redis/6379Executable : /usr/local/bin/redis-serverCli Executable : /usr/local/bin/redis-cliIs this ok? Then press ENTER to go on or Ctrl-C to abort.Copied /tmp/6379.conf =&gt; /etc/init.d/redis_6379Installing service...Successfully added to chkconfig!Successfully added to runlevels 345!/var/run/redis_6379.pid exists, process is already running or crashedInstallation successful!# 手动开启|关闭|重启redis服务/etc/init.d/redis_6379 start|stop|restart# 或者service redis_6379 start|stop|restart# 如果设置了redis密码，需要在自动启动脚本位置更改一下命令，否则stop命令提示没有权限vim /etc/init.d/redis_6379$CLIEXEC -a &quot;your_password&quot; -p $REDISPORT shutdown# 查看redis是否启动ps -ef | grep redisroot 1946 1 0 17:31 ? 00:00:00 /usr/local/bin/redis-server *:6379 # 查看redis版本redis-cli -v# 测试redis是否启动成功，有密码时用redis-cli -a 密码redis-cli127.0.0.1:6379&gt; PINGPONG 关闭开机自动启动redis 123456789# 显示自动启动的redis设置情况chkconfig --list | grep redisredis_6379 0:off 1:off 2:on 3:on 4:on 5:on 6:off# 关闭或开启自动启动，后续可以开启chkconfig --level 2345 redis_6639 off|on# 或者chkconfig redis_6639 off|on# 删除自动启动，后续可以用 ./utils/install_server.sh重新添加chkconfig --del redis_6639 其他常用配置 1、防止background save db 不成功 1234567#修改linux内核配置vim /etc/sysctl.conf# 添加vm.overcommit_memory = 1# 重启或用如下命令立即生效sysctl -psysctl vm.overcommit_memory **解释：内核参数overcommit_memory ** 它是 内存分配策略，可选值：0、1、2。 0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2， 表示内核允许分配超过所有物理内存和交换空间总和的内存 2、禁用linux内核特性transparent huge pages，关闭透明大页功能 12345678# 对内存使用和延迟有非常大的负面影响echo never &gt; /sys/kernel/mm/transparent_hugepage/enabledecho never &gt; /sys/kernel/mm/redhat_transparent_hugepage/enabled# cat /sys/kernel/mm/redhat_transparent_hugepage/enabledalways madvise [never]# cat /sys/kernel/mm/transparent_hugepage/enabledalways madvise [never] 3、无需停机升级或重启 Redis 实例。 1234# 这个命令可以看到所有可以config配置的参数127.0.0.1:6379&gt; config get *# 用config set设置，注意此时并不会修改你的6379.conf文件中的requirepass，重启后依旧是之前的密码config set requirepass newpass 4、redis-cli客户端中文乱码 1redis-cli --raw -a password redis基本类型Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。 二进制安全的字符串 Lists: 按插入顺序排序的字符串元素的集合。他们基本上就是链表（linked lists）。 Sets: 不重复且无序的字符串元素的集合。 Sorted sets,类似Sets,但是每个字符串元素都关联到一个叫score浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素。（例如你可能会问：给我前面10个或者后面10个元素）。 Hashes,由field和关联的value组成的map。field和value都是字符串的。这和Ruby、Python的hashes很像。 Bit arrays (或者说 simply bitmaps): 通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。 HyperLogLogs: 这是被用于估计一个 set 中元素数量的概率性的数据结构。 命名规则redis的key可以用任何二进制序列，空字符串也可以，但是推荐统一风格，不过于简化也不过于复杂 object-key : id : field 如： user:1000:name user:1000:reply.to 公共方法12345678910111213141516171819# 查看系统所有的变量&gt; keys *# 判断key值存储的类型&gt; type name&quot;string&quot;# 判断key是否存在，1：存在； 0：不存在&gt; exists name(integer) 1&gt; exists nokey(integer) 0# 删除keydel deldemo(integer) 1del deldemo(integer) 0 其他命令备忘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 1、redis-cli执行命令报错,可以用auth命令输入密码(error) NOAUTH Authentication required.&gt; auth passowrdOK# 2、返回所有连接到服务器的客户端信息和统计数据&gt; client listid=42661 addr=127.0.0.1:36864 fd=12 name= age=201 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=clientid=42660 addr=10.1.*.22:45290 fd=10 name= age=226 idle=10 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=select# 3、显示所有redis配置信息&gt; info# Serverredis_version:5.0.5redis_git_sha1:00000000executable:/usr/local/redis/bin/redis-serverconfig_file:/etc/redis/6379.conf# Clientsconnected_clients:7client_recent_max_input_buffer:2# Memoryused_memory:1032400used_memory_human:1008.20K# Persistenceloading:0rdb_changes_since_last_save:328# Statstotal_connections_received:42670total_commands_processed:5904618# Replicationrole:masterconnected_slaves:0# CPUused_cpu_sys:2300.225530used_cpu_user:3141.746346# Clustercluster_enabled:0# Keyspacedb0:keys=8,expires=7,avg_ttl=2143172852155db6:keys=241,expires=238,avg_ttl=926857# 4、选择数据库（默认0~15一共16个数据库）127.0.0.1:6379&gt; select 16(error) ERR DB index is out of range127.0.0.1:6379&gt; select 15OK127.0.0.1:6379[15]&gt; select 0OK127.0.0.1:6379&gt; # 5、redis清库# 清除当前库&gt; flushdb OK127.0.0.1:6379&gt; keys *(empty list or set)# 清除所有库flushall String类型设置字符串的值1234567891011121314151617181920# 设置值&gt; set name &quot;kk&quot;OK&gt; get name&quot;kk&quot;# 一条命令设置多个值&gt; mset age 3 birth 2010/01/01OK&gt; mget age birth1) &quot;3&quot;2) &quot;2010/01/01&quot;# 现有的key尾部追加值&gt; append name &quot; lee&quot;6 # 返回追加值之后key的长度[kk] + [ lee] = 6&gt; get name&quot;kk lee&quot;# 得到值长度strlen name(integer) 6 数据在限定时间存活方法1：对存在的key设置过期时间 1234567&gt; set phone 110# 10s后删除phone&gt; expire 10# 过期后get key的值为nil&gt; get phone(nil) 方法2：设置值时同时指定过期时间 12&gt; set phone 110 ex 10OK 公共方法 1234567891011# 得到剩余存活时间 ttl phone(integer) 5 # 剩余秒数(integer) -2 # 已经过期(integer) -1 # key无过期时间，是永久的# 取消过期设定persist phone(integer) 1 # 设置成功persist phone(integer) 0 # phone这个key原来就是永久的 原子递增减，重置123456789101112131415161718# 原子递增&gt; incr age(integer) 4# 指定增加多少&gt; incrby age 10(integer) 14# 同理原子递减&gt; decr age(integer) 13&gt; decrby age 14(integer) -1# 数值重置，且返回重置前的值&gt; getset age 3&quot;-1&quot;&gt; get age&quot;3&quot; 其他补遗decrby age -2 = incrby age 2 # 增加浮点数 incrbyfloat price 2.122 位操作 getbit key offset setbit key offset value bitcount key [start][end] bitop operation destkey key[key …] List类型一般意义上讲列表就是有序元素的序列，数组实现跟列表实现的list，属性方面大不相同 列表list：头尾添加元素速度极快且相同，跟list到底有多少值无关 数组list：索引访问元素速度极快 Redis的列表类型（list）可以存储一个有序的字符串列表，通常的操作是向列表两端添加元素，或者获取列表的某一个片段。其内部使用双向链表（double linked list）实现的，所以两端添加元素的时间复杂度是O(1)，获取越接近两端元素的速度就越快。快速访问集合元素能力不行 设置List值123456789101112131415161718192021222324252627282930313233343536373839404142434445# rpush向右侧末尾添加元素，显示添加后的list数量rpush list 0 1 2 3 4 5(integer) 6# 显示0~2共3个位置的元素，注意list只有一个lrange用于显示list值，没有rrangelrange list 0 21) &quot;0&quot;2) &quot;1&quot;3) &quot;2&quot;# -1代表最后一个元素lrange list 0 -11) &quot;0&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;3&quot;5) &quot;4&quot;6) &quot;5&quot;# 右侧末尾弹出1个元素，返回弹出的元素值rpop list&quot;5&quot;# 左侧头部添加元素lpush list a b c dlrange list 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;0&quot; 6) &quot;1&quot; 7) &quot;2&quot; 8) &quot;3&quot; 9) &quot;4&quot; # 左侧头部弹出1个元素，返回被弹出的元素值lpop list&quot;d&quot;lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;0&quot;5) &quot;1&quot;6) &quot;2&quot;7) &quot;3&quot;8) &quot;4&quot; 异常情况12345# 一个list一直弹，最后无元素可弹时，返回nil，且此时删除该键rpop poplist(nil)exists poplist(integer) 0 列表常用命令123456789101112131415161718192021222324252627282930rpush mylist 1 2 3 4 5 (integer) 5# 列表截取127.0.0.1:6379&gt; ltrim mylist 0 2OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;# 设置某个值的数据127.0.0.1:6379&gt; lset mylist 0 11OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;11&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; lset mylist -1 33OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;11&quot;2) &quot;2&quot;3) &quot;33&quot;# 列表长度127.0.0.1:6379&gt; llen mylist(integer) 3# 删除列表值为2的元素；0 ：删除所有；127.0.0.1:6379&gt; lrem mylist 0 2(integer) 1 移除source列表最后一个元素，插入destination列表头部 rpoplpush source destination brpoplpush source destination timeout # 阻塞版，0：代表无限期阻塞 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 示例del list1 list2(integer) 2rpush list1 1 2 3 4(integer) 4# 如果目标list不存在的话会创建一个rpoplpush list1 list2&quot;4&quot;keys list*1) &quot;list1&quot;2) &quot;list2&quot;lrange list2 0 -11) &quot;4&quot;lrange list1 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;# 如果源list不存在返回nilrpoplpush list3 list1(nil)# 只有rpoplpush，即弹出源末尾值插入目标头部lpoprpush list2 list1(error) ERR unknown command 'lpoprpush'# 源跟目标都有值时可以更明显看出127.0.0.1:6379&gt; lrange list1 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;d&quot;127.0.0.1:6379&gt; rpoplpush list1 list2&quot;3&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;3&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;d&quot;# 源跟目标一样时末尾元素移到头部，旋转列表127.0.0.1:6379&gt; rpoplpush list2 list2&quot;d&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;d&quot;2) &quot;3&quot;3) &quot;a&quot;4) &quot;b&quot;5) &quot;c&quot; Hash类型Redis Hset 命令用于为哈希表中的字段赋值 。 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，旧值将被覆盖。 返回值如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。 12HSET KEY_NAME FIELD VALUEHGET KEY_NAME FIELD 举例 1234567hset website google &quot;google.com&quot;hset website baidu &quot;baidu.com&quot;hget website googlehgetall website 2017-05-23 23:15 更新列表list命令用法，困了:-s睡觉去","link":"/2017/05/10/redis_abc/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"}]}